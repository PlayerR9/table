// This command generates a table of the given type implemented as a boundless table (i.e., out-of-bounds errors are not thrown).
//
// To use it, run the following command:
//
// //go:generate go run github.com/PlayerR9/table/cmd/table -name=<type_name> -type=<type> [ -g=<generics>] [ -o=<output_file> ]
//
// **Flag: Name**
//
// The "name" flag is used to specify the name of the table. As such, it must be set and,
// not only does it have to be a valid Go identifier, but it also must start with an upper case letter.
//
// **Flag: Type**
//
// The "fields" flag is used to specify type of the table's cells. This flag must be set.
//
// For instance, running the following command:
//
//	//go:generate treenode -name=Table -type=int
//
// will generate a table with the following structure:
//
//	type Table struct {
//		table [][]int
//	}
//
// It is important to note that spaces are not allowed in any of the flags.
//
// Also, it is possible to specify generics by following the value with the generics between square brackets;
// like so: "MyType[T,C]"
//
// **Flag: Generics**
//
// This optional flag is used to specify the type(s) of the generics. However, this only applies if at least one
// generic type is specified in the type flag. If none, then this flag is ignored.
//
// As an edge case, if this flag is not specified but the type flag contains generics, then
// all generics are set to the default value of "any".
//
// Its argument is specified as a list of key-value pairs where each pair is separated
// by a comma (",") and a slash ("/") is used to separate the key and the value. The key indicates the name of
// the generic and the value indicates the type of the generic.
//
// For instance, running the following command:
//
//	//go:generate table -name=Table -type=MyType[T] -g=T/any
//
// will generate a table with the following fields:
//
//	type Table[T any] struct {
//		table [][]T
//	}
//
// **Flag: Output File**
//
// This optional flag is used to specify the output file. If not specified, the output will be written to
// standard output, that is, the file "<type_name>_table.go" in the root of the current directory.
package main

import (
	"flag"
	"log"
	"text/template"

	uc "github.com/PlayerR9/MyGoLib/Units/common"
	ggen "github.com/PlayerR9/MyGoLib/go_generator"
)

var (
	// Logger is the logger to use.
	Logger *log.Logger

	// t is the template to use.
	t *template.Template
)

func init() {
	Logger = ggen.InitLogger("table")

	t = template.Must(template.New("").Parse(templ))
}

var (
	TypeNameFlag *string
)

func init() {
	TypeNameFlag = flag.String("name", "", "The name of the generated type. It must be set.")

	ggen.SetOutputFlag("<type>_table.go", false)

	ggen.SetTypeListFlag("type", true, 1, "The type of each table's cell.")
	ggen.SetGenericsSignFlag("g", false, 1)
}

// GenData is the data struct for the generator.
type GenData struct {
	// PackageName is the package name of the generated code.
	PackageName string

	// TypeName is the name of the generated type.
	TypeName string

	// TypeSig is the signature of the generated type.
	TypeSig string

	// GenericsSign is the signature of the generics.
	GenericsSign string

	// CellType is the type of each table's cell.
	CellType string
}

// SetPackageName implements the go_generator.Generater interface.
func (g GenData) SetPackageName(pkg_name string) ggen.Generater {
	g.PackageName = pkg_name

	return g
}

func main() {
	err := ggen.ParseFlags()
	if err != nil {
		Logger.Fatalf("Could not parse flags: %s", err.Error())
	}

	type_name := uc.AssertNil(TypeNameFlag, "TypeNameFlag")

	err = ggen.IsValidName(type_name, nil, ggen.Exported)
	if err != nil {
		Logger.Fatalf("Could not validate type name: %s", err.Error())
	}

	output_loc, err := ggen.FixOutputLoc(type_name, "_table.go")
	if err != nil {
		Logger.Fatalf("Could not fix output location: %s", err.Error())
	}

	data := GenData{
		TypeName:     type_name,
		GenericsSign: ggen.GenericsSigFlag.String(),
	}

	err = ggen.Generate(output_loc, data, t,
		func(data GenData) GenData {
			type_sig, err := ggen.MakeTypeSig(type_name, "")
			if err != nil {
				Logger.Fatalf("Could not make type signature: %s", err.Error())
			}

			data.TypeSig = type_sig

			return data
		},
		func(data GenData) GenData {
			cell_type, err := ggen.TypeListFlag.GetType(0)
			if err != nil {
				Logger.Fatalf("Could not get cell type: %s", err.Error())
			}

			data.CellType = cell_type

			return data
		},
	)
	if err != nil {
		Logger.Fatalf("Could not generate code: %s", err.Error())
	}
}

const templ = `// Code generated by go:generate. DO NOT EDIT.
package {{ .PackageName }}

import "github.com/PlayerR9/MyGoLib/Units/common"

// {{ .TypeName }}{{ .GenericsSign }} represents a table of cells that can be drawn to the screen.
type {{ .TypeName }}{{ .GenericsSign }} struct {
	table         [][]{{ .CellType }}
	width, height int
}

// Iterator implements the common.Iterable interface.
//
// The returned iterator is a pull-model iterator that scans the table row by row 
// as it was an array of elements of type {{ .CellType }}.
//
// Example:
//
//	[ a b c ]
//	[ d e f ]
//
//	Iterator() -> [ a ] -> [ b ] -> [ c ] -> [ d ] -> [ e ] -> [ f ]
func (t *{{ .TypeSig }}) Iterator() common.Iterater[{{ .CellType }}] {
	iter := common.NewDynamicIterator(
		common.NewSimpleIterator(t.table),
		func(row []{{ .CellType }}) common.Iterater[{{ .CellType }}] {
			return common.NewSimpleIterator(row)
		},
	)

	return iter
}

// Cleanup implements the Utility.Cleaner interface.
//
// It sets all cells in the table to the zero value of type {{ .CellType }}.
func (t *{{ .TypeSig }}) Cleanup() {
	for i := 0; i < t.height; i++ {
		t.table[i] = make([]{{ .CellType }}, t.width)
	}
}

// New{{ .TypeName }} creates a new table of type {{ .CellType }} with the given width and height.
// Negative parameters are treated as absolute values.
//
// Parameters:
//   - width: The width of the table.
//   - height: The height of the table.
//
// Returns:
//   - *{{ .TypeSig }}: The new table. Never nil.
func New{{ .TypeName }}{{ .GenericsSign }}(width, height int) *{{ .TypeSig }} {
	if width < 0 {
		width = -width
	}

	if height < 0 {
		height = -height
	}

	table := make([][]{{ .CellType }}, height)
	for i := 0; i < height; i++ {
		table[i] = make([]{{ .CellType }}, width)
	}

	return &{{ .TypeSig }}{
		table:  table,
		width:  width,
		height: height,
	}
}

// GetWidth returns the width of the table.
//
// Returns:
//   - int: The width of the table. Never negative.
func (t *{{ .TypeSig }}) GetWidth() int {
	return t.width
}

// GetHeight returns the height of the table.
//
// Returns:
//   - int: The height of the table. Never negative.
func (t *{{ .TypeSig }}) GetHeight() int {
	return t.height
}

// WriteAt writes a cell to the table at the given coordinates. However, out-of-bounds
// coordinates do nothing.
//
// Parameters:
//   - x: The x-coordinate of the cell.
//   - y: The y-coordinate of the cell.
//   - cell: The cell to write to the table.
func (t *{{ .TypeSig }}) WriteAt(x, y int, cell {{ .CellType }}) {
	if x < 0 || x >= t.width || y < 0 || y >= t.height {
		return
	}

	t.table[y][x] = cell
}

// GetAt returns the cell at the given coordinates in the table. However, out-of-bounds
// coordinates return the zero value of type {{ .CellType }}.
//
// Parameters:
//   - x: The x-coordinate of the cell.
//   - y: The y-coordinate of the cell.
//
// Returns:
//   - {{ .CellType }}: The cell at the given coordinates.
func (t *{{ .TypeSig }}) GetAt(x, y int) {{ .CellType }} {
	if x < 0 || x >= t.width || y < 0 || y >= t.height {
		return *new({{ .CellType }})
	} else {
		return t.table[y][x]
	}
}

// WriteVerticalSequence is a function that writes the specified values to the table
// starting from the specified coordinates (top = 0, 0) and continuing down the
// table in the vertical direction until either the sequence is exhausted or
// the end of the table is reached; at which point any remaining values in the
// sequence are ignored.
//
// Due to implementation details, any value that would be written outside are ignored.
// As such, if x is out-of-bounds, the function does nothing and, if y is out-of-bounds,
// only out-of-bounds values are not written.
//
// Parameters:
//   - x: The x-coordinate of the starting cell. (Never changes)
//   - y: The y-coordinate of the starting cell.
//   - sequence: The sequence of cells to write to the table.
//
// At the end of the function, the y coordinate points to the cell right below the
// last cell in the sequence that was written.
//
// Example:
//
//	// [ a b c ]
//	// [ d e f ]
//	//
//	// seq := [ g h i ], x = 0, y = -1
//
//	WriteVerticalSequence(x, y, seq)
//
//	// [ h b c ]
//	// [ i e f ]
//	//
//	// x = 0, y = 2
//
// As you can see, the 'g' value was ignored as it would be out-of-bounds.
// Finally, if either x or y is nil, the function does nothing.
func (t *{{ .TypeSig }}) WriteVerticalSequence(x, y *int, sequence []{{ .CellType }}) {
	if x == nil || y == nil {
		return
	}

	actualX, actualY := *x, *y

	if len(sequence) == 0 || actualX < 0 || actualX >= t.width || actualY >= t.height {
		return
	}

	if actualY < 0 {
		sequence = sequence[-actualY:]

		*y = 0
	} else if actualY+len(sequence) > t.height {
		sequence = sequence[:t.height-actualY]
	}

	for i, cell := range sequence {
		t.table[actualY+i][actualX] = cell
	}

	*y += len(sequence)
}

// WriteHorizontalSequence is the equivalent of WriteVerticalSequence but for horizontal
// sequences.
//
// See WriteVerticalSequence for more information.
//
// Parameters:
//   - x: The x-coordinate of the starting cell.
//   - y: The y-coordinate of the starting cell.
//   - sequence: The sequence of cells to write to the table.
func (t *{{ .TypeSig }}) WriteHorizontalSequence(x, y *int, sequence []{{ .CellType }}) {
	if x == nil || y == nil {
		return
	}

	actualX, actualY := *x, *y

	if len(sequence) == 0 || actualY < 0 || actualY >= t.height || actualX >= t.width {
		return
	}

	if actualX < 0 {
		sequence = sequence[-actualX:]

		*x = 0
	} else if actualX+len(sequence) > t.width {
		sequence = sequence[:t.width-actualX]
	}

	copy(t.table[actualY][actualX:], sequence)

	*x = actualX + len(sequence)
}

// GetFullTable returns the full table as a 2D slice of elements of type {{ .CellType }}.
//
// Returns:
//   - [][]{{ .CellType }}: The full table.
func (t *{{ .TypeSig }}) GetFullTable() [][]{{ .CellType }} {
	return t.table
}

// IsXInBounds checks if the given x-coordinate is within the bounds of the table.
//
// Parameters:
//   - x: The x-coordinate to check.
//
// Returns:
//   - error: An error of type *common.ErrOutOfBounds if the x-coordinate is out of bounds.
func (t *{{ .TypeSig }}) IsXInBounds(x int) error {
	if x < 0 || x >= t.width {
		return common.NewErrOutOfBounds(x, 0, t.width)
	} else {
		return nil
	}
}

// IsYInBounds checks if the given y-coordinate is within the bounds of the table.
//
// Parameters:
//   - y: The y-coordinate to check.
//
// Returns:
//   - error: An error of type *common.ErrOutOfBounds if the y-coordinate is out of bounds.
func (t *{{ .TypeSig }}) IsYInBounds(y int) error {
	if y < 0 || y >= t.height {
		return common.NewErrOutOfBounds(y, 0, t.height)
	} else {
		return nil
	}
}

// WriteTableAt is a convenience function that copies the values from the given
// table to the table starting at the given coordinates in a more efficient way 
// than using any other methods.
//
// While it acts in the same way as both WriteVerticalSequence and WriteHorizontalSequence
// combined, it is more efficient than calling those two functions separately.
//
// See WriteVerticalSequence for more information.
//
// Parameters:
//   - table: The table to write to the table.
//   - x: The x-coordinate to write the table at.
//   - y: The y-coordinate to write the table at.
//
// If the table is nil, x or y are nil, nothing happens.
func (t *{{ .TypeSig }}) WriteTableAt(table *{{ .TypeSig }}, x, y *int) {
	if table == nil || x == nil || y == nil {
		return
	}

	offsetX, offsetY := 0, 0
	X, Y := *x, *y

	for offsetY < table.height && Y+offsetY < t.height {
		offsetX = 0

		for offsetX < table.width && X+offsetX < t.width {
			t.table[Y+offsetY][X+offsetX] = table.table[offsetY][offsetX]
			offsetX++
		}

		offsetY++
	}

	*x += offsetX
	*y += offsetY
}
`
